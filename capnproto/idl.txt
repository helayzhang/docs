@0xdbb9ad1f14bf0b36;  # unique file ID, generated by `capnp id`

struct Person {
  name @0 :Text;
  birthdate @3 :Date;

  email @1 :Text;
  phones @2 :List(PhoneNumber);

  struct PhoneNumber {
    number @0 :Text;
    type @1 :Type;

    enum Type {
      mobile @0;
      home @1;
      work @2;
    }
  }
}

struct Date {
  year @0 :Int16;
  month @1 :UInt8;
  day @2 :UInt8;
}

Some notes:
    · 类型在字段名后面
    · @N展示了协议是如何演进的，系统可以确保兼容旧版本。字段、枚举、接口方法都必须按照添加的顺序，从0开始连续编号。
    与protobuf不同，定义字段时是不允许跳过编号数字的，并且没有任何理由这样做。

Language Reference:
    
    Comments
        # This is a comment.
        注释出现在定义之后，在同一行或下一行。
        整体注释应该定义在花括号之后的第二行。
        将注释放在定义后面会让代码可读性更高，尤其当注释越来越长。

        struct Date {
            # A standard Gregorian calendar date.

            year @0 :Int16;
            # The year.  Must include the century.
            # Negative value indicates BC.
        
            month @1 :UInt8;    # Month number, 1-12.
            day @2 :UInt8;      # Day number, 1-30.
        }

    Built-in Types 内置基本数据类型
        · Void:                 Void
        · Boolean:              Bool
        · Integers:             Int8, Int16, Int32, Int64
        · Unsigned Integers:    UInt8, UInt16, UInt32, UInt64
        · Floating-Point:       Float32, Float64
        · Blobs:                Text, Data
        · Lists:                List(T)

        Notes:
        · Void类型有且只有一个值，因此序列化后占用0bits。Void很少使用，但在union中作为成员很有用。
        · Text是UTF-8编码且NUL结尾的。
        · Data是任意字节序列。
        · List是带参数的类型，参数指定了List中的元素类型。例如List(Int32), List(Person), List(List(Text))。

    Structs
        结构中由一组命名了、有类型的、从0开始连续编号的字段组成。
        struct Person {
            name @0 :Text;
            email @1 :Text;
        }
        字段可以有默认值：
            foo @0 :Int32 = 123;
            bar @1 :Text = "blah";
            baz @2 :List(Bool) = [true, false, false, true];
            qux @3 :Person = (name = "Bob", email = "bob@example.com")
            corge @4 :Void = void;
            grault @5 :Data = 0x"a1 40 33";

    Unions
        联合体由结构体中的2个或以上字段组成，他们存储在同一个位置上。同一时刻他们中只有一个值可以被设置，有一个特殊的标志专门用来维护他们中哪个当前被设置了。
        和C中的联合体不同，联合只不过是字段的一个属性，因此联合体声明的形式和普通类型是不同的。
        struct Person {
            # ...

            employment :union {
                # We assume that a person is only one of these.
                unemployed @4 :Void;
                employer @5 :Company;
                school @6 :School;
                selfEmployed @7 :Void;
            }
        }
        联合体可以是匿名的，但每个结构体只能最多包含一个匿名联合体。当你在给union取名时感到困惑时，可以用匿名。
        struct Shape {
            area @0 :Float64;
        
            union {
                circle @1 :Float64;      # radius
                square @2 :Float64;      # width
            }
        }
        Notes: 
        · 联合体成员和结构体成员是在一个数字编号空间里的。编号的目的是指示结构体演进的顺序。系统需要知道联合体里的字段是何时加入到这些非联合体字段中的。
        · 在这里我们使用了Void类型。因为unemployed和selfEmployed没有额外信息，但我们仍然需要把他们和其他字段区分出来。
        · 默认情况下，当结构体被初始化时，union里最小编号的字段是被设置的。如果你不想任何字段默认被设置，那么就把编号最小的字段命名为unset。
        · 你可以把一个存在的字段移动到union去，只要union里的其他字段都是新字段，就不会破坏和已有数据的兼容性。因为这个移动的字段是union里必定是最小编号的字段，他将是union里的默认字段。

        union不是一级类型，这样设计的优点：
        · 如果union是一级类型，union里的成员需要和包含它的外层字段之间区分开来并独立编号，对于编译器而言，当需要计算union在上层struct中的位置时就需要谨慎的假定任何类型都可能未来加入到union中。
        为此所有的union必须被单独分配成指针并嵌入进来，这样会浪费空间。
        · union可独立存在会对协议演进不利，因为未来没法增加通用字段。
        · 协议演进时经常会发现一些现有的字段应当包含在union内，因为新加的字段往往与一些现有字段是互斥的。在Cap'nProto的union设计基础上，我们有能力把这样的现存字段逆向union化，并且不会破坏读取旧数据的
        能力，这样就不会浪费空间。而这个能力只有当union被声明在struct内才具备。

        Cap'n Proto的非传统式union设计提供了以上优点，同时也没有带来任何不足。当你想要定义一个独立存在的union时，只需要定义一个struct，内部仅仅包含一个union就好了（往往用匿名union），这样你会达到
        同样的效果。这种方式可能不太直观，但确实具备更强大的能力。

    Groups
        Group是一些字段的集合，他们被封装在一个独立空间内。
        struct Person {
            # ...

            address :group {
                # Note: This is a terrible way to use groups, and meat only to demostrate the syntax.
                houseNumber @8 :UInt32;
                street @9 :Text;
                city @10 :Text;
                country @11 :Text;
            }
        }
        上面这个group定义效果就和定义一个嵌套的struct类型Address，并定义一个字段address :Address。但是group并不是一个独立存在的对象，group内的字段和外层字段是在一起编号的。
        在内存中group中的字段组织和他们没被包含在group中时是完全一样的。因此，group仅仅是一个namespace。
        以上例子中的单个group存在意义并不大，就像Void类似。但当他们和union一起使用时便会更有意思：
        struct Shape {
            area @0 :Float64;

            union {
                circle :group {
                    radius @1 :Float64;
                }
                rectangle :group {
                    width @2 :Float64;
                    height @3 :Float64;
                }
            }
        }
        将group和union一起使用有两个主要理由：
        · group具备一定的自描述能力。例如radius现在是circle的一个成员，这样我们便不再需要注释来说明circle的值是radius。
        · 你能在未来增加更多的字段，并且不打破兼容性。上面的例子中，我们将square演进为rectangle，并且增加了一个height字段。这个版本的协议和之前的版本是完全兼容的，只是对于老的数据height字段会读到
        零值。在实际使用中，经常会后知后觉的发现你需要为union中的特定字段增加一些字段，如果不具备将字段升级为group的能力，你只能重新定义再一个新的独立union字段，并无意义的浪费空间。

        注意：一个命名的union作用和一个包含匿名union的命名group是完全一样的。

        在Protobuf中，group被认为是一个错误的设计，为什么Cap'n Proto又需要它？
        · group配合union是十分有用的，而Protobuf不支持union。同时，Cap'n Proto中并不存在"repeated group"，而这是Protobuf中group问题最大的场景。
        
    Dynamically-typed Fields 动态定义类型的字段
        struct里可以包含AnyPointer类型的字段。这种字段的值可以是任意指针类型。例如：任意struct、interface、list或blob。就和C语言中的void*类似。

    Enums
        枚举值是一小组有限的预定义符号值。
        enum Rfc3092Variable {
            foo @0;
            bar @1;
            baz @2;
            qux @3;
            # ...
        }
        就像字段一样，枚举值必须从0开始编号，在那些枚举值有数字值的语言中，编号值对应了枚举值的数值。但一般Cap'n Proto的枚举值不应当认为是一种数字。

    Interfaces
        接口是一组方法，每一个方法包括一些参数和返回值。就像struct里的字段，接口里的方法也是需要编号的。接口支持继承。以及多重继承。
        interface Node {
            isDirectory @0 () -> (result :Bool);
        }
        
        interface Directory extends(Node) {
            list @0 () -> (list :List(Entry));
            struct Entry {
                name @0 :Text;
                node @1 :Node;
            }

            create @1 (name :Text) -> (file :File);
            mkdir @2 (name :Text) -> (directory :Directory);
            open @3 (name :Text) -> (node :Node);
            delete @4 (name :Text);
            link @5 (name :Text, node :Node);
        }

        interface File extends(Node) {
            size @0 () -> (size :UInt64);
            read @1 (startAt :UInt64 = 0, amount :UInt64 = 0xffffffffffffffff)
                -> (data :Data);
            # Default params = read entire file.
            write @2 (startAt :UInt64, data :Data);
            truncate @3 (size :UInt64);
        }
        Node, Directory, File是接口，但有些方法把他们作为参数或返回值类型。Directory.Entry是个struct，他里面包含一个Node字段，Node是一个接口类型。
        Struct以及基础数据类型在RPC中是以值传递的，Interface则是以引用传递。因此当Directory.list在远程被调用时，List(Entity)的内容被返回，其中包含了name的值，但node里包含的是远程Node的地址。

        当一个对象的地址被传输，rpc系统会自动保证接受者能调用这个地址的对象，因为如果接收方没有调用权限，发送方就不应当发送这个地址。这样基于Cap'n Proto开发安全协议是十分容易的，
        几乎不再需要考虑权限问题。这个功能使得Cap'n Proto成为一个基于能力的RPC系统，一个对象的引用内含了一层含义：调用它的能力。

    Generic Types 泛型类型
        Struct或Interface类型可以有可变参数，这样的类型具备“泛型”的能力。例如：用这种方式定义类型通用的容器很有用：
        struct Map(Key, Value) {
            entries @0 :List(Entry);
            struct Entry {
                key @0 :Key;
                value @1 :Value;
            }
        }
        
        struct People {
            byName @0 :Map(Text, Person);
            # Maps names to Person instances.
        }
        Cap'n Proto的泛型的工作模式和C++模板十分类似，注意以下几点：
        · 只有指针类型能用于泛型参数（structs、lists、blobs、interfaces），这一点和Java类似。这是一种务实的限制，如果允许非指针类型参数用于泛型，会导致不同的参数实例化后的struct的结构分布完全不同，
        这会使Cap'n Proto的实现大大复杂化。
        · 在泛型类型里内嵌的子类型定义是可以用外层的泛型参数的，正如以上的例子。这一点与Java不同，但和C++一致。如果你要使用泛型中的内嵌类型，你必须指定外层类型的泛型参数类型。例如，这样用Map(Text, Person).Entry，
        而不是Map.Entry(Text, Person)。当然，内嵌类型也可以定义额外的泛型参数。
        · 如果不指定泛型参数的方式来使用泛型类型（例如用Map，而不是Map(T, U)），这样相当于用AnyPointer做泛型参数。这种类型能兼容任意其他泛型参数的数据，主要在运行时你用正确的类型去解析AnyPointer即可。
        · 类似的，把一个具体化的泛型类型转换成一个所有参数都是AnyPointer的泛型类型是安全的, 只要在运行时用正确的类型解析即可。这样server实现可以对所有类型通用，而client调用时可以指定特定的类型。
        · 泛型指定具体参数后的编码结果，和一个手动定义的同样类型的非泛型类型是完全一样的。例如：Map(Text, Person)编码后的结果和以下类型是一样的：
        struct PersonMap {
            # Encoded the same as Map(Text, Person).
            entries @0 :List(Entry);
            struct Entry {
                key @0 :Text;
                value @1 :Person;
            }
        }
        所以，把一个非泛型的类型升级为泛型类型是可行的，并且能保持向前兼容。
        · 类似的，一个泛型的interface协议，和一个手动定义的同样类型的非泛型的interface是一样的。

    Generic Methods 泛型方法
        interface方法也可以针对一次调用使用泛型参数。这是常见的用于工厂方法的方式。例如：
        interface Assignable(T) {
            # A generic interface, with non-generic methods.
            get @0 () -> (value :T);
            set @1 (value :T) -> ();
        }

        interface AssignableFactory {
            newAssignable @0 [T] (initialValue :T) -> (assignable :Assignable(T));
            # A generic method.
        }
        这里，这个方法是泛型方法。返回的类型取决于输入的类型。
        理想状态下调用一个泛型方法不需要显示指定泛型类型，因为他们可以从方法的常规参数上推导得到，然而这个特性要根据编程语言和api细节来决定。
        注意，如果一个方法的泛型类型仅仅用于返回值而没有用于入参，则隐含返回值适合任意参数。例如：
            newUnsetAssignable @1 [T] () -> (assignable :Assignable(T));
            # Create a new assignable. `get()` on the returned object will
            # throw an exception until `set()` has been called at least once.
        因为这种定义方式最初返回的Assignable是适用于任意T类型的，实际上，直到第一次调用set()之前他都没有指定T类型。
        如果返回类型是未知的，那么不应该使用泛型，而应该使用AnyPointer，或忽略一个类型参数（这样他们默认就是AnyPointer），例如：
            getNamedAssignable @2 (name :Text) -> (assignable :Assignable);
            # Get the `Assignable` with the given name. It is the 
            # responsibility of the caller to keep track of the type of each
            # named `Assignable` and cast the returned object appropriately.
        这里的返回值里我们忽略了Assignable的泛型参数，因为一个返回的对象是有特定类型的，但在定义时并不知道是什么类型。

    Constants
        我们能定义常量。他们不会影响在线上传输的数据，但在生成代码中他们会被包含，并且可以用capnp工具计算。
            const pi :Float32 = 3.14159;
            const bob :Person = (name = "Bob", email = "bob@example.com");
            const secret :Data = 0x"9f98739c2b53835e 6720a00907abd42f";
        可以在一个常量定义中引用另一个值（另一个常量，或另一个字段的默认值）。
            const foo :Int32 = 123;
            const bar :Text = "Hello";
            const baz :SomeStruct = (id = .foo, message = .bar);
        当需要用一个常量代替一个值时，这个常量名必须在同一个代码块中是合法的。例如，一个常量qux嵌套定义在Corge中，那么引用时需要指定Corge.qux而不是qux，
        即使在Corge内部也是如此。在最外层声明的常量用.前缀来访问。这样指定的名字指向一个用户定的常量，而不是一个文字值或一个枚举值。

    Nesting, Scope and Aliases
        常量、别名、类型定义可以内嵌到structs和interfaces中（但枚举值不能）。嵌套定义不会对其定义的方式本身有任何影响，而仅仅是指定了他的Scope（域）。
        因此如果你使用Java，那么其内部class总是static的。在另一个域中引用一个嵌套定义的类型，需要用.分隔域路径。
        struct Foo {
            struct Bar {
                # ...
            }
            bar @0 :Bar;
        }
        struct Baz {
            bar @0 :Foo.Bar;
        }
        当路径太长输入太冗长时，可以用using来声明一个别名：
        struct Qux {
            using Foo.Bar;
            bar @0 :Bar;
        }
        struct Corge {
            using T = Foo.Bar;
            bar @0 :T;
        }

    Imports
        import语句指定了其他文件中的域。
        struct Foo {
            baz @0 :import "bar.capnp".Baz;
            # Use type "Baz" defined in bar.capnp.
        }
    
        using Bar = import "bar.capnp";
        struct Foo {
            baz @0 :Bar.Baz;
            # Use type "Baz" defined in bar.capnp.
        }

        using import "bar.capnp";
        struct Foo {
            baz @0 :Baz;
            # Use type "Baz" defined in bar.capnp;
        }
        以上import使用了相对路径来引入。如果路径以/开头，那么则是绝对路径。如果用绝对路径时，capnp将搜索-I选项指定的那些目录。

    Annotations 释文
        有时候我们需要附加一些额外信息，到我们的协议中，这些并不属于Cap'n Proto语言的一部分。这些信息有时会控制一些特殊的代码生成，或者你可能会在运行时读取这些数据来
        做一些动态处理。例如，你可能会构造一个字段的释文，并叫做"hive from the public"，当你给另一个用户发送消息时，你可能会写一些代码处理你的消息，先把这些字段移除。
        你可以这样声明和使用释文：
        annotation foo(struct, enum) :Text;
        # Declare an annotation 'foo' which applies to struct and enum types.

        struct MyType $foo("bar") {
            # Apply 'foo' to MyType.
        }

        能被释文作用的目标包括：file, struct, field, union, group, enum, enumerant, interface, method, parameter, annotation, const. 可以用*来支持所有类型。
        annotation baz(*) :Int32;
        # 'baz' can annotate anything!

        $baz(1); # Annotate the file.

        struct MyStruct $baz(2) {
            myField @0 :Text = "default" $baz(3);
            myUnion :union $baz(4) {
            }
        }

        enum MyEnum $baz(5) {
            myEnumerant @0 $baz(6);
        }

        interface MyInterface $baz(7) {
            myMethod @0 (myParam :Text $baz(9)) -> () $baz(8);
        }

        annotation myAnnotation(struct) :Int32 $baz(10);
        const myConst :Int32 = 123 $baz(11);

        Void类型的释文可以不用指定值，struct类型的释文也可以不用指定值。小技巧：如果你需要释文有个默认值，把他申明为一个struct并且仅包含一个有默认值的字段。
        annotation qux(struct, field) :Void;

        struct MyStruct $qux {
            string @0 :Text $qux;
            number @1 :Int32 $qux;
        }

        annotation corge(file) :MyStruct;

        $corge(string = "hello", number = 123);

        struct Grault {
            value @0 :Int32 = 123;
        }

        annotation grault(file) :Grault;

        $grault(); # value default to 123
        $grault(value = 456);

    Unique IDs
        一个Cap'n Proto的文件必须包含一个64bit的唯一ID，并且每个类型和释文的定义也可以有一个ID。用capnp id工具可以随机生成一个新的ID。ID指定以@符号打头。
        @0xdbb9ad1f14bf0b36;
        # file ID

        struct Foo @0x8db435604d0d3723 {
            # ...
        }

        enum Bar @0xb400f69b5334aab3 {
            # ...
        }

        interface Baz @0xf7141baba3c12691 {
            # ...
        }
    
        annotation qux @0xf8a1bedf44c89f00 (field) :Text;
        如果一个类型或释文的ID被省略了，会自动指定一个。默认的ID生成自是父域的ID的MD5 hash值的前8字节和声明名字的连接（在最外层定义时父域是文件名，嵌套定义时指的是外层类型）。
        你可以用-ocapnp选项来编译来看到自动生成的ID，会带有额外信息的schema打印到终端上，例如capnp compile -ocapnp myschema.capnp。
        总之，只有当一个声明改名或移动了，而你需要保持ID不变来向前兼容时才需要显示指定一个ID。

        ID的存在提供了一种简短、无二义的方式来从另一个上下文中引用一个类型、释文。他们可以用来代表schemas，标记动态类型字段等。

    Evolving Your Protocol
        协议用以下方式修改时，可以保持向前兼容，并且不改变消息的标准化编码：
        · 新类型、常量、别名可以加到任何地方，因为他们不会影响已有类型的编码。
        · 新标签、枚举值、方法可以加到structs、enums、interfaces，只要每次添加新的成员的编号比之前所有的编号都大。类似的，新的字段可以加到已有groups和unions。
        · 新的参数可以加到methods，新的参数必须加到参数列表的末尾，并且必须有默认值。
        · 成员可以重新排布，只要他们的编号不发生变化。
        · 符号名可以任意变化，只要他们的ID/顺序编号保持不变。注意类型声明有一个隐含的ID，是基于他们的name和父ID生成的，但是你可以用capnp compile -ocapnp myschema.capnp来找到这个ID，
        并当需要重命名时显示的指定这个ID。
        · 类型定义可以移动到不同的域中，只要类型ID显示声明的情况下。
        · 一个字段可以移动到一个group或一个union中，只要这个group/union以及所有其内部的其他字段都是新添加的。换句话说，一个字段可以用一个包含了这个字段和一些新字段的group或union所替换。
        · 一个非泛型类型可以改成泛型类型，已有的泛型类型可以添加新的泛型参数。新生成的泛型类型中内部使用的其他类型可以被替换成新的泛型参数，只要现有的使用方把泛型类型绑定成所替换的类型。例如：
        struct Map {
            entries @0 :List(Entry);
            struct Entry {
                key @0 :Text;
                value @1 :Text;
            }
        }
        可以修改成：
        struct Map(Key, Value) {
            entries @0 :List(Entry);
            struct Entry {
                key @0 :Key;
                value @1 :Value;
            }
        }
        只要已有用户把Map替换成Map(Text, Text)，Map.Entry替换成Map(Text, Text).Entry。
        这个规则对泛型方法也类似适用。

        协议用以下方式修改时，可以保持向前兼容，但可能会改变消息的标准化编码。那些依赖标准化的APP（例如加密协议）需要避免以下方式，但是大部分APP可以安全的使用它们：
        · 一个List(T)类型的标签，T可以是基础类型、blob、list，可以修改成List(U)，U可以是一个struct类型，包含@0号字段是类型T。
        这个规则在你太晚发现你需要给List元素添加更多数据的时候十分有用。如果没有这个规则，你需要定义一个平级的list，这样很容易出错。
        一个特例，List(Bool)不能被更新成一个struct，因为要对bit list类型支持这个规则成本太高了。

        除了以上方式，其他方式对协议的修改认为是不安全的：
        · 不能修改一个字段、method、或枚举的编号
        · 不能修改一个字段、method参数的类型或默认值
        · 不能修改一个类型的ID
        · 不能修改一个没有显式指定ID的类型的名字，因为隐式ID一部分是根据类型名字生成的
        · 不能移动一个没有显式指定ID的类型到另一个域或者文件，因为隐式ID一部分是根据域ID生成的
        · 不能把一个已存在的字段移进或移出一个已存在的union，你也不能构造一个包含超过一个已有字段的新union
        


        























