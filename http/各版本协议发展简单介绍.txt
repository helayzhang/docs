本文摘自网络博客，部分描述尚需考证。

1. HTTP/0.9

	HTTP是基于TCP/IP协议的应用层协议。最早版本是1991年发布的0.9版本。该版本极其简单，只有一个命令GET。
	协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。
	服务器发送完毕，就关闭TCP连接。

2. HTTP/1.0

	2.1 简介
		1996年5月，HTTP/1.0 版本发布，内容大大增加。
		首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。
		其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。
		再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。
		其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等

	2.2 关于Content-Type字段
		1.0版本规定，头信息必须是ASCII编码，后面的数据可以是任何格式。Content-Type指示数据是什么格式，常见的有：
			text/plain
			text/html
			text/css
			image/jpeg
			image/png
			image/svg+xml
			audio/mp4
			video/mp4
			application/javascript
			application/pdf
			application/zip
			application/atom+xml
		总称位MIME type，每个值包括一级类型和二级类型，用斜杠分隔。除了预定义的类型，厂商也可以自定义类型。
		MIME type还可以在尾部使用分号，添加参数。例如：
			Content-Type: text/html; charset=utf-8
		客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式：
			Accept: */*

	2.3 关于Content-Encoding字段
		Content-Encoding字段说明数据的压缩方法。
			Content-Encoding: gzip			—— gzip压缩
			Content-Encoding: compress		—— compress压缩
			Content-Encoding: deflate    	—— zlib压缩
		客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法：
			Accept-Encoding: gzip, deflate

	2.4 缺点
		HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源就必须再新建一个连接。
		为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段：
			Connection: keep-alive
		这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段：
			Connection: keep-alive
		一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本解决办法。

3. HTTP/1.1

	1997年1月，HTTP/1.1 版本发布，只比1.0 版本晚了半年。它进一步完善了HTTP协议，一直用到了20年后的今天，直到现在还是最流行的版本。

	3.1 持久连接
		1.1 版本最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用申明Connection: keep-alive。
		客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。规范的做法是，客户端在最后一个请求时，发送Connection: clode，明确要求服务器关闭TCP连接。
		目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。

	3.2 管道机制（pipelining）
		1.1 版本引入了管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。（和1.0 版本的区别在于，以前需要等待前一个请求的回应收到后，客户端才能发出下一个请求，而管道机制下允许客户端同时发出多个请求，服务器则依然是按顺序回应多个请求）

	3.3 Content-Length字段
		Content-Length字段声明本次回应的数据长度。在1.0版本中，Content-Length字段不是必须的，因为浏览器发现服务器关闭了TCP连接就表明收到的数据包已经全了。

	3.4 分块传输编码
		使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。
		对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成才能发送数据，现在这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用“流模式”（stream）渠道“缓存模式”（buffer）。
		因此，1.1版本规定可以不适用Content-Length字段，而使用“分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。
			Transfer-Encoding: chunked
		每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完毕。

	3.5 其他功能
		1.1 版本还新增了许多动词方法：PUT、PATCH、HEAD、OPTIONS、DELETE。
		新增了Host字段，用来制定服务器的域名。
			Host: www.example.com
		有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。

	3.6 缺点
		虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为“队头堵塞”（Head-of-line blocking）。
		为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。

4. SPDY协议

	2009年，谷歌公开了自行研发的SPDY协议，主要解决HTTP/1.1效率不高的问题。
	这个协议在Chrome浏览器上证明可行以后，就被当做HTTP/2的基础，主要特性都在HTTP/2之中得到继承。

5. HTTP/2
	
	2015年，HTTP/2发布。

	5.1 二进制协议
		HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为“帧”（frame）：头信息帧和数据帧。
		二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。

	5.2 多工
		HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了“队头堵塞”。
		举例来说，在一个TCP连接里面，服务器同时受到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分，接着回应B请求，完成后，再发送A请求剩下的部分。
		这样的双向、实时的通信，就叫多工（Multiplexing）。

	5.3 数据流
		因为HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此必须要对数据包做标记，指出它属于哪个回应。
		HTTP/2将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。

		数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2可以取消某一次的请求，同时保证TCP连接还打开着，可以被其他请求使用。

		客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

	5.4 头信息压缩
		HTTP协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，必须Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

		HTTP/2对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

	5.5 服务器推送
		HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。
		常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

引用：
	http://www.ruanyifeng.com/blog/2016/08/http.html

解读和思考：
	经过查阅《HTTP权威指南》关于连接管理方面的资料，验证如下：
	1.0版本一个连接处理一次请求，完后就关闭。
	1.0版本的keep-alive，支持了复用一个连接做多次请求，前一次请求和回应完毕后，不关闭连接，下次请求可以复用。（减少了TCP连接建立的延迟，但请求之间完全串行处理）
	1.1版本默认就是持久化连接，并增加了管道化连接机制，同一个TCP连接允许同时发送多个请求，服务器顺序回复请求，要求发送的请求是幂等性的（如GET），否则在出错情况下执行结果是客户端不可得知
	2版本中的多工复用，由于协议用二进制帧的形式表达，并且用流id来区别不同的请求，支持服务器乱序处理和响应不同的请求（由于HTTP大多数请求之间是不存在依赖性的，乱序也没有问题），同时引入了流控和优先级、流之间的依赖等机制，来解决一些不允许乱序的场景












